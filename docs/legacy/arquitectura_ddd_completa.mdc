---
description:
globs:
alwaysApply: false
---
# Arquitectura Domain-Driven Design (DDD) Completa

## 1. Principios Fundamentales y Estructura

### 1.1. Visión General

Domain-Driven Design (DDD) es un enfoque para el desarrollo de software que:

- Coloca el dominio del problema como centro del diseño
- Crea un lenguaje ubicuo compartido entre expertos técnicos y de dominio
- Aísla la lógica de negocio en un modelo de dominio rico
- Organiza el código en capas con responsabilidades bien definidas

La arquitectura sigue el principio de dependencia hacia el núcleo:
- La capa de Dominio es el núcleo y no depende de ninguna otra capa
- Cada capa externa solo puede depender de capas más internas
- Las dependencias externas se abstraen mediante interfaces

```
Presentación → Aplicación → Dominio ← Datos
                      ↘       ↑     ↗ 
                       Infraestructura
```

### 1.2. Estructura de Capas

#### Capa de Dominio
- Define entidades y agregados
- Encapsula reglas de negocio en entidades
- Define interfaces de repositorio
- Establece contratos y validaciones

#### Capa de Aplicación
- Implementa casos de uso
- Define DTOs para transferencia de datos
- Coordina entre entidades de dominio
- Implementa mapeo con AutoMapper

#### Capa de Datos
- Implementa repositorios definidos en dominio
- Gestiona persistencia (Entity Framework o Firebase)
- Configura mapeos ORM
- Optimiza queries y cache

#### Capa de Infraestructura
- Configura inyección de dependencias
- Gestiona autenticación y logging
- Proporciona servicios técnicos
- Maneja excepciones globales

#### Capa de Presentación
- Expone endpoints API
- Maneja validaciones básicas de entrada
- Devuelve respuestas HTTP adecuadas
- Documenta API con Swagger

## 2. Flujos de Comunicación Entre Capas

### 2.1. Solicitud HTTP → Controlador (Capa de Presentación)

1. El usuario realiza una solicitud HTTP a un endpoint
2. El controlador recibe la solicitud y los datos
3. El controlador valida los datos básicos de formato
4. El controlador llama al servicio de aplicación correspondiente

```csharp
[HttpPost]
public async Task<ActionResult> Create([FromBody] CategoryCreateDto data)
{
    await _categoryAppService.Create(data);
    return CreatedAtAction(nameof(GetById), new { id = data.Id }, null);
}
```

### 2.2. Controlador → Servicio de Aplicación

1. El servicio de aplicación recibe el DTO con los datos
2. El servicio valida los datos de negocio
3. El servicio mapea el DTO a entidades usando AutoMapper
4. El servicio coordina la lógica invocando métodos en las entidades
5. El servicio utiliza repositorios para persistir los cambios

```csharp
public Task Create(CategoryCreateDto data)
{
    if (data is null)
    {
        throw new InvalidValueException("The request is not valid.");
    }
    Category category = Category.Create(data.Id);
    category.SetName(data.Name);
    return _categoryRepository.Create(category);
}
```

### 2.3. Servicio de Aplicación → Entidad de Dominio

1. La entidad encapsula el comportamiento y las reglas de negocio
2. La entidad realiza validaciones, lanzando excepciones si es necesario
3. La entidad modifica su estado interno basado en el comportamiento invocado

```csharp
public void SetName(string name)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new InvalidValueException("The category name can't be null/empty.");
    }

    Name = name;
    UpdateEditDate();
}
```

### 2.4. Servicio de Aplicación → Repositorio

1. El servicio llama a métodos del repositorio para persistir o recuperar entidades
2. La interfaz del repositorio está definida en la capa de dominio
3. La implementación concreta está en la capa de datos

```csharp
public interface ICategoryRepository : IRepository<Category>
{
    // Métodos específicos para Category
}
```

### 2.5. Repositorio → Base de Datos

1. La implementación del repositorio traduce operaciones de dominio a operaciones de DB
2. Utiliza el contexto para interactuar con la base de datos
3. Gestiona el mapeo entre entidades y esquema de base de datos

```csharp
public override Task<Category> GetById(Guid id)
{
    return _context.Set<Category>()
        .Include(category => category.Flows)
        .FirstOrDefaultAsync(category => category.Id == id);
}
```

### 2.6. Flujo de Retorno de Datos

1. El repositorio recupera datos y los mapea a entidades de dominio
2. El servicio de aplicación recibe entidades del repositorio
3. El servicio mapea las entidades a DTOs usando AutoMapper
4. El controlador recibe los DTOs y los devuelve como respuesta HTTP

```csharp
public async Task<CategoryReadDto> GetById(Guid CategoryId)
{
    Category category = await _categoryRepository.GetByIdOrThrow(CategoryId, query => 
        query.Include(c => c.Flows)
             .ThenInclude(f => f.Nodes));

    return _mapper.Map<Category, CategoryReadDto>(category);
}
```

## 3. Buenas Prácticas y Patrones

### 3.1. Validaciones por Capa

- **Capa de Presentación**: Formato, requeridos, tipos de datos
- **Capa de Aplicación**: Reglas complejas que involucran múltiples entidades
- **Capa de Dominio**: Invariantes de entidad, reglas fundamentales

### 3.2. Manejo de Excepciones

- Las entidades lanzan excepciones específicas de dominio
- Los servicios de aplicación pueden transformar estas excepciones
- La infraestructura proporciona manejador global
- Los controladores devuelven códigos HTTP apropiados

### 3.3. Prácticas Recomendadas

1. **Encapsulamiento**: Propiedades con getters públicos y setters privados
2. **Validaciones**: Las entidades validan sus propios invariantes
3. **Métodos Factory**: Uso de métodos estáticos (Create) para instanciar entidades
4. **Interfaces**: Definición de contratos en el dominio
5. **DTOs**: Objetos específicos para transferencia de datos
6. **AutoMapper**: Mapeo entre entidades y DTOs
7. **Inyección de Dependencias**: Uso de interfaces en lugar de implementaciones
8. **Métodos Asíncronos**: Uso de Task/Task<T> para operaciones asíncronas

## 4. Adaptación con Firebase y React Frontend

### 4.1. Arquitectura Adaptada

La arquitectura implementa adaptaciones específicas para:

1. **Backend con Firebase**: La capa de datos utiliza Firestore en lugar de una DB relacional
2. **Frontend Separado**: Aplicación React/TypeScript que se comunica vía API REST

```
┌─────────────────────────────────────────┐      ┌─────────────────────────────────┐
│ BACKEND (C#)                            │      │ FRONTEND (React/TypeScript)     │
│                                         │      │                                 │
│ ┌───────────┐  ┌───────────────────┐    │      │ ┌───────────┐ ┌──────────┐     │
│ │  Domain   │  │   Application     │    │      │ │  Models   │ │Presenters│     │
│ │  Layer    │◄─┤   Layer           │    │      │ │  (Domain) │◄┤(Applica- │     │
│ │           │  │                   │    │      │ │           │ │ tion)    │     │
│ └───┬───────┘  └──────────┬────────┘    │      │ └───────────┘ └──────┬───┘     │
│     │                     │             │      │                       │         │
│     ▼                     ▼             │      │                       ▼         │
│ ┌───────────┐  ┌───────────────────┐    │      │ ┌───────────┐ ┌──────────┐     │
│ │  Data     │  │   Presentation    │    │   API │ │ Services  │ │  Views   │     │
│ │ Layer     │  │   Layer (API)     │◄───┼──────┼─┤ (Infraestr│ │  (UI)    │     │
│ │(Firebase) │  │                   │    │ REST  │ │  ucture)  │ │          │     │
│ └─────┬─────┘  └───────────────────┘    │      │ └───────────┘ └──────────┘     │
│       │                                 │      │                                 │
│       ▼                                 │      │                                 │
│ ┌───────────┐                           │      │                                 │
│ │ Firebase  │                           │      │                                 │
│ │ Firestore │                           │      │                                 │
│ └───────────┘                           │      │                                 │
└─────────────────────────────────────────┘      └─────────────────────────────────┘
```

### 4.2. Backend con Firebase (Capa de Datos)

- **FirebaseDbContext**: Centraliza el acceso a Firestore
- **Repositorios Firebase**: Implementan interfaces definidas en el dominio
- **Mapeo manual**: Conversión entre documentos Firestore y entidades

```csharp
// Ejemplo de repositorio para Firebase
public class CategoryRepository : ICategoryRepository
{
    private readonly FirebaseDbContext _firebaseContext;
    private readonly string _collectionName = "categories";

    public CategoryRepository(FirebaseDbContext firebaseContext)
    {
        _firebaseContext = firebaseContext;
    }

    public async Task<IEnumerable<Category>> GetAll()
    {
        var snapshot = await _firebaseContext.FirestoreDb
            .Collection(_collectionName)
            .GetSnapshotAsync();

        return snapshot.Documents
            .Select(doc => ConvertToEntity(doc))
            .ToList();
    }
    
    // Más métodos...
}
```

### 4.3. Estructura Frontend (React/TypeScript)

La aplicación frontend implementa DDD adaptado al frontend y patrón MVP:

```
frontend/
  ├── src/
  │   ├── models/             # Modelos de dominio (Domain Layer)
  │   │   ├── common/         # Interfaces y tipos comunes
  │   │   ├── categories/     # Modelos específicos de dominio
  │   │
  │   ├── services/           # Servicios de API (Infrastructure Layer)
  │   │   ├── api/            # Comunicación con backend via REST
  │   │
  │   ├── presenters/         # Lógica de casos de uso (Application Layer)
  │   │   ├── categories/     # Hooks personalizados para categorías
  │   │
  │   ├── views/              # Componentes de UI (Presentation Layer)
  │   │   ├── components/     # Componentes reutilizables (Atomic Design)
  │   │   ├── pages/          # Páginas de la aplicación
```

#### Patrón MVP en React

- **Model**: Objetos de dominio en `src/models/`
- **View**: Componentes React en `src/views/`
- **Presenter**: Custom hooks en `src/presenters/`

```typescript
// Ejemplo de presenter (custom hook)
export function useCategoryPresenter() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(false);
  const categoryService = new CategoryService();

  const loadCategories = async () => {
    setLoading(true);
    try {
      const data = await categoryService.getAll();
      setCategories(data.map(dto => new Category(dto)));
    } catch (error) {
      // Manejo de errores
    } finally {
      setLoading(false);
    }
  };

  return { categories, loading, loadCategories };
}
```

#### Comunicación con Backend

El frontend se comunica EXCLUSIVAMENTE con el backend a través de API REST:

```typescript
// Ejemplo de servicio API
export class CategoryService {
  private readonly baseUrl = "/api/categories";

  async getAll(): Promise<CategoryDto[]> {
    const response = await axios.get(this.baseUrl);
    return response.data;
  }

  async create(category: CategoryCreateDto): Promise<string> {
    const response = await axios.post(this.baseUrl, category);
    return response.data;
  }
}
```

### 4.4. Flujo de Datos Completo (Frontend-Backend-Firebase)

1. **Usuario → React Component**
2. **Component → Presenter (Custom hook)**
3. **Presenter → Service (API)**
4. **Service → Backend API (Controlador)**
5. **Controlador → Servicio de Aplicación**
6. **Servicio → Entidades de Dominio**
7. **Servicio → Repositorio**
8. **Repositorio → Firebase**

## 5. Ejemplos de Código por Capas

### 5.1. Capa de Dominio

| Archivo                                                                      | Descripción                                                 |
| ---------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [1_Domain_Entity.cs](../DDD_Ejemplos_Codigo/1_Domain_Entity.cs)             | Entidad de dominio con validaciones y encapsulamiento       |
| [2_Domain_Repository_Interface.cs](../DDD_Ejemplos_Codigo/2_Domain_Repository_Interface.cs) | Interfaz de repositorio |

### 5.2. Capa de Aplicación

| Archivo                                                                                          | Descripción                             |
| ------------------------------------------------------------------------------------------------ | --------------------------------------- |
| [5_Application_DTO.cs](../DDD_Ejemplos_Codigo/5_Application_DTO.cs)                             | DTOs para diferentes operaciones        |
| [7_Application_Service_Implementation.cs](../DDD_Ejemplos_Codigo/7_Application_Service_Implementation.cs) | Servicios de aplicación |

### 5.3. Capa de Datos

| Archivo                                                                                                        | Descripción                  |
| -------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| [3_Data_Repository_Implementation.cs](../DDD_Ejemplos_Codigo/3_Data_Repository_Implementation.cs)             | Implementación de repositorio |
| [15_Firebase_Repository_Implementation.cs](../DDD_Ejemplos_Codigo/15_Firebase_Repository_Implementation.cs)   | Repositorio Firebase |

### 5.4. Capa de Presentación

| Archivo                                                                              | Descripción                 |
| ------------------------------------------------------------------------------------ | --------------------------- |
| [9_Presentation_Controller.cs](../DDD_Ejemplos_Codigo/9_Presentation_Controller.cs) | Controlador API con Swagger |

### 5.5. Frontend React

| Archivo | Descripción |
| ------- | ----------- |
| [18_React_Model.tsx](../DDD_Ejemplos_Codigo/18_React_Model.tsx) | Modelos e interfaces TypeScript |
| [19_React_Service.tsx](../DDD_Ejemplos_Codigo/19_React_Service.tsx) | Servicios API para comunicación |
| [20_React_Presenter.tsx](../DDD_Ejemplos_Codigo/20_React_Presenter.tsx) | Presentadores (hooks) |
| [21_React_View.tsx](../DDD_Ejemplos_Codigo/21_React_View.tsx) | Componentes React (vistas) |

## 6. Implementación Paso a Paso

1. Comenzar por el dominio, definiendo entidades y sus comportamientos
2. Definir interfaces de repositorio en el dominio
3. Implementar servicios de aplicación que coordinen casos de uso
4. Implementar repositorios concretos (Firebase o relacional)
5. Configurar inyección de dependencias
6. Desarrollar controladores API
7. Crear frontend React con arquitectura MVP
8. Integrar frontend y backend

## 7. Consideraciones 

### 7.1. Seguridad
- Frontend nunca accede directamente a Firebase
- Autenticación vía JWT en todas las comunicaciones API
- Validación en ambos lados (frontend y backend)

### 7.2. Rendimiento
- Paginación en consultas grandes
- Prefetching de datos comunes
- Lazy loading de componentes

### 7.3. Mantenibilidad
- Código autodocumentado con nombres significativos
- Separación clara de responsabilidades
- Tests automatizados para cada capa
