---
description: Template and guidelines for 3_Data_Repository_Implementation.cs.
autoAttach: true
filePattern: "regex:src/Data/.*/Repositories/.+Repository\.cs$"
---

# 3_Data_Repository_Implementation.cs Guideline

## Purpose
This rule automatically attaches when you are working on files that match **src/Data/.*/Repositories/.+Repository\.cs$**.  
It embeds the full reference implementation so you can copy‑paste or use it as a template.

## Template code
```csharp
// EJEMPLO DE IMPLEMENTACIÓN DE REPOSITORIO (Data Layer)
// Ruta: src/Data/TuProyecto.Data/Repositories/Categories/CategoryRepository.cs

namespace TuProyecto.Data.Repositories.Categories;

using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using TuProyecto.Data.Core.Contexts;
using TuProyecto.Data.Core.Repositories;
using TuProyecto.Domain.Models.Categories;
using TuProyecto.Domain.Models.Flows;
using TuProyecto.Domain.Repositories.Categories;
using TuProyecto.Domain.Core.Specifications;

/// <summary>
/// Características clave de una implementación de repositorio en DDD:
/// 1. Implementa la interfaz definida en el dominio
/// 2. Hereda de una clase base Repository<T> que implementa operaciones comunes
/// 3. Utiliza Entity Framework Core para acceso a datos
/// 4. Utiliza especificaciones para definir includes y filtros
/// 5. No lanza excepciones de dominio directamente - esto es responsabilidad de la capa de aplicación
/// </summary>
public class CategoryRepository : Repository<Category>, ICategoryRepository
{
    private readonly ApplicationContext _context;

    public CategoryRepository(ApplicationContext context) : base(context)
    {
        _context = context;
    }

    // Método genérico para buscar entidades utilizando una especificación
    public async Task<Category> FindAsync(ISpecification<Category> specification)
    {
        return await ApplySpecification(specification).FirstOrDefaultAsync();
    }

    // Método genérico para buscar múltiples entidades utilizando una especificación
    public async Task<IEnumerable<Category>> FindAllAsync(ISpecification<Category> specification)
    {
        return await ApplySpecification(specification).ToListAsync();
    }

    // Método base para aplicar una especificación a un query
    private IQueryable<Category> ApplySpecification(ISpecification<Category> specification)
    {
        var query = _context.Set<Category>().AsQueryable();

        // Aplicar los includes definidos en la especificación
        if (specification.Includes.Any())
        {
            query = specification.Includes.Aggregate(query,
                (current, include) => current.Include(include));
        }

        // Aplicar los filtros definidos en la especificación
        if (specification.Criteria != null)
        {
            query = query.Where(specification.Criteria);
        }

        return query;
    }

    // Sobrescribimos el método base para incluir relaciones usando especificaciones
    public override Task<Category> GetById(Guid id)
    {
        // Usamos una especificación predefinida para obtener categoría con sus flujos
        return FindAsync(new CategoryWithFlowsSpecification(id));
    }

    // Método para obtener sin incluir las relaciones
    public Task<Category> GetByIdWithoutFlows(Guid id)
    {
        return _context.Set<Category>()
            .AsNoTracking()
            .FirstOrDefaultAsync(category => category.Id == id);
    }

    // Implementación de operación específica sin lanzar excepciones de dominio
    public async Task AddFlowToCategory(Guid categoryId, Guid flowId)
    {
        Category category = await _context.Set<Category>()
            .Include(c => c.Flows)
            .FirstOrDefaultAsync(c => c.Id == categoryId);

        if (category == null)
        {
            return; // No lanzamos excepciones, el servicio de aplicación manejará el caso null
        }

        Flow flow = await _context.Set<Flow>()
            .FirstOrDefaultAsync(f => f.Id == flowId);

        if (flow == null)
        {
            return; // No lanzamos excepciones, el servicio de aplicación manejará el caso null
        }

        category.AddFlow(flow);
        _context.Update(category);
        await _context.SaveChangesAsync();
    }

    // Implementación de operación específica sin lanzar excepciones de dominio
    public async Task RemoveFlowFromCategory(Guid categoryId, Guid flowId)
    {
        Category category = await _context.Set<Category>()
            .Include(c => c.Flows)
            .FirstOrDefaultAsync(c => c.Id == categoryId);

        if (category == null)
        {
            return; // No lanzamos excepciones, el servicio de aplicación manejará el caso null
        }

        Flow flow = await _context.Set<Flow>()
            .FirstOrDefaultAsync(f => f.Id == flowId);

        if (flow == null)
        {
            return; // No lanzamos excepciones, el servicio de aplicación manejará el caso null
        }

        category.RemoveFlow(flow);
        _context.Update(category);
        await _context.SaveChangesAsync();
    }
}

// Ejemplo de una especificación para consultas con includes específicos
public class CategoryWithFlowsSpecification : BaseSpecification<Category>
{
    public CategoryWithFlowsSpecification(Guid id)
    {
        Criteria = c => c.Id == id;
        AddInclude(c => c.Flows);
    }
}
```
