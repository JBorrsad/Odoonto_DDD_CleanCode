---
description: Guidelines for integrating Firebase Firestore as the data source layer.
alwaysApply: true
globs: 
- "src/Data/**"
- "src/Infrastructure/**"
---

> Versión 1.0 · 2025-05-13

# Guía Firebase + Frontend React

## Arquitectura con API REST y Firebase en el Backend

Esta guía describe la arquitectura donde el frontend React se comunica exclusivamente con un backend .NET mediante una API REST, y es este backend quien interactúa con Firebase como sistema de persistencia de datos, reemplazando a una base de datos relacional tradicional.

### 1. Visión General de la Arquitectura

La arquitectura sigue un diseño Domain-Driven Design (DDD) puro:

```
┌─────────────────────┐       ┌───────────────────────────────────────────────────┐       ┌───────────────┐
│                     │       │                   BACKEND (.NET)                   │       │               │
│                     │       │                                                   │       │               │
│                     │       │ ┌───────────┐  ┌───────────┐  ┌───────────┐       │       │               │
│    FRONTEND         │       │ │           │  │           │  │           │       │       │               │
│    (React/          │  API  │ │ Presenta- │  │ Applica-  │  │  Domain   │       │       │               │
│    TypeScript)      ├───────┼─► tion      ├──► tion      ├──►           │       │       │               │
│                     │  REST │ │ Layer     │  │ Layer     │  │  Layer    │       │       │    Firebase   │
│                     │       │ │ (API)     │  │           │  │           │       │       │    Firestore  │
│                     │       │ │           │  │           │  │           │       │       │  (Persistencia│
│                     │       │ └─────┬─────┘  └─────┬─────┘  └─────┬─────┘       │       │    de datos)  │
│                     │       │       │              │              │             │       │               │
│                     │       │       │              │              │             │       │               │
│                     │       │       └──────────────┼──────────────┘             │       │               │
│                     │       │                      │                            │       │               │
│                     │       │              ┌───────▼─────┐                      │       │               │
│                     │       │              │             │                      │       │               │
│                     │       │              │ Data Layer  ├──────────────────────┼───────►               │
│                     │       │              │ (Firebase)  │                      │       │               │
│                     │       │              │             │                      │       │               │
│                     │       │              └─────────────┘                      │       │               │
│                     │       │                                                   │       │               │
└─────────────────────┘       └───────────────────────────────────────────────────┘       └───────────────┘
```

**IMPORTANTE:**

- El frontend NUNCA se comunica directamente con Firebase
- La API REST sigue siendo necesaria como punto de entrada para todas las operaciones
- Firebase solo reemplaza la capa de persistencia, no cambia la arquitectura general

### 2. Componentes de la Arquitectura

#### 2.1. Frontend (React/TypeScript)

El frontend es una aplicación React/TypeScript completamente separada que:

- Se comunica EXCLUSIVAMENTE con el backend a través de la API REST
- Nunca accede directamente a Firebase
- Sigue patrón MVP (Model-View-Presenter) internamente
- Se sitúa ÚNICAMENTE en la capa de Presentación según DDD

#### 2.2. Backend API (ASP.NET Core)

La API REST es la capa de Presentación del backend:

- Expone endpoints documentados con Swagger
- Se implementa con controladores ASP.NET Core
- Utiliza servicios de la capa de Aplicación
- No contiene lógica de negocio

#### 2.3. Capa de Datos con Firebase

La capa de Datos es donde se implementa la interacción con Firebase:

- Implementa las interfaces de repositorio definidas en el dominio
- Utiliza el SDK de Firebase para C#
- Abstrae completamente los detalles de Firebase del resto de la aplicación

### 3. Implementación de Componentes de Firebase

#### 3.1. FirebaseDbContext

Este componente central proporciona acceso a Firestore y abstrae detalles de conexión:

```csharp
// EJEMPLO: FirebaseDbContext
// Ruta: src/Data/Odoonto.Data.Core/Firebase/FirebaseDbContext.cs

namespace Odoonto.Data.Core.Firebase;

using System;
using System.IO;
using Google.Cloud.Firestore;
using Microsoft.Extensions.Configuration;

public class FirebaseDbContext
{
    public FirestoreDb FirestoreDb { get; private set; }

    public FirebaseDbContext(IConfiguration configuration)
    {
        Initialize(configuration);
    }

    private void Initialize(IConfiguration configuration)
    {
        try
        {
            // Obtener la configuración desde appsettings.json o variables de entorno
            string projectId = configuration["Firebase:ProjectId"];
            string credentialsPath = configuration["Firebase:CredentialsPath"];

            // Usar archivo de credenciales JSON
            if (!string.IsNullOrEmpty(credentialsPath))
            {
                Environment.SetEnvironmentVariable("GOOGLE_APPLICATION_CREDENTIALS", credentialsPath);
                FirestoreDb = FirestoreDb.Create(projectId);
                return;
            }

            // O usar credenciales en línea
            string credentials = configuration["Firebase:Credentials"];
            if (!string.IsNullOrEmpty(credentials))
            {
                // Convertir credenciales a archivo temporal
                string tempPath = Path.Combine(Path.GetTempPath(), $"firebase_credentials_{Guid.NewGuid()}.json");
                File.WriteAllText(tempPath, credentials);
                Environment.SetEnvironmentVariable("GOOGLE_APPLICATION_CREDENTIALS", tempPath);
                FirestoreDb = FirestoreDb.Create(projectId);
                File.Delete(tempPath);
                return;
            }

            // Detección automática (para entornos Google Cloud)
            FirestoreDb = FirestoreDb.Create(projectId);
        }
        catch (Exception ex)
        {
            throw new ApplicationException("Error initializing Firebase connection", ex);
        }
    }

    // Métodos de ayuda para operaciones comunes
    public CollectionReference GetCollection(string collectionName)
    {
        return FirestoreDb.Collection(collectionName);
    }

    public DocumentReference GetDocument(string collectionName, string documentId)
    {
        return FirestoreDb.Collection(collectionName).Document(documentId);
    }
}
```

#### 3.2. Extensiones para facilitar el mapeo

```csharp
// EJEMPLO: FirebaseDbContextExtensions
// Ruta: src/Data/Odoonto.Data.Core/Firebase/FirebaseDbContextExtensions.cs

namespace Odoonto.Data.Core.Firebase;

using Google.Cloud.Firestore;
using System;
using System.Collections.Generic;

public static class FirebaseDbContextExtensions
{
    private static readonly Dictionary<string, object> _converters = new();

    public static void RegisterConverter<TEntity, TDocument>(
        this FirebaseDbContext context,
        string collectionName, 
        Func<TEntity, TDocument> toDocument,
        Func<TDocument, TEntity> toDomainEntity)
    {
        _converters[GetConverterKey<TEntity>(collectionName)] = new
        {
            ToDocument = toDocument,
            ToDomainEntity = toDomainEntity
        };
    }

    public static CollectionReference GetCollectionWithConverter<TEntity>(
        this FirebaseDbContext context, 
        string collectionName = null)
    {
        string resolvedCollection = collectionName ?? GetDefaultCollectionName<TEntity>();
        
        // Obtener el converter registrado
        var key = GetConverterKey<TEntity>(resolvedCollection);
        if (!_converters.TryGetValue(key, out var converterObj))
        {
            throw new InvalidOperationException($"No converter registered for {typeof(TEntity).Name} in collection {resolvedCollection}");
        }

        // Obtener los métodos de conversión usando reflection
        dynamic converter = converterObj;
        Func<TEntity, object> toDocument = (Func<TEntity, object>)converter.ToDocument;
        Func<object, TEntity> toDomainEntity = (Func<object, TEntity>)converter.ToDomainEntity;

        // Crear y retornar la colección con el converter configurado
        return context.FirestoreDb.Collection(resolvedCollection)
            .WithConverter(new FirestoreConverter<TEntity>
            {
                ToFirestore = (entity) => ConvertToDictionary(toDocument(entity)),
                FromFirestore = (snapshot) => toDomainEntity(ConvertFromDictionary(snapshot))
            });
    }

    // Métodos de ayuda
    private static string GetConverterKey<T>(string collectionName)
    {
        return $"{typeof(T).FullName}:{collectionName}";
    }

    private static string GetDefaultCollectionName<T>()
    {
        // Convención: nombre de la clase en plural y lowercase
        return typeof(T).Name.ToLowerInvariant() + "s";
    }

    private static Dictionary<string, object> ConvertToDictionary(object document)
    {
        // Implementación para convertir el documento a Dictionary<string, object>
        // (Usando reflection o serialización)
        return new Dictionary<string, object>();
    }

    private static object ConvertFromDictionary(DocumentSnapshot snapshot)
    {
        // Implementación para convertir el snapshot a un objeto
        return new object();
    }
}
```

#### 3.3. Inyección de Dependencias para Firebase

```csharp
// EJEMPLO: FirebaseInyector
// Ruta: src/Infrastructure/Odoonto.Infrastructure.InversionOfControl/Inyectors/FirebaseInyector.cs

namespace Odoonto.Infrastructure.InversionOfControl.Inyectors;

using Microsoft.Extensions.DependencyInjection;
using Odoonto.Data.Core.Firebase;
using Odoonto.Data.Mappings;
using Odoonto.Data.Repositories.Patients;
using Odoonto.Data.Repositories.Doctors;
using Odoonto.Domain.Repositories.Patients;
using Odoonto.Domain.Repositories.Doctors;

public static class FirebaseInyector
{
    public static void Inyect(IServiceCollection services)
    {
        // Registro del contexto Firebase como Singleton
        services.AddSingleton<FirebaseDbContext>();

        // Registro de mappers
        services.AddScoped<IPatientMapper, PatientMapper>();
        services.AddScoped<IDoctorMapper, DoctorMapper>();
        services.AddScoped<IOdontogramMapper, OdontogramMapper>();
        
        // Registro de repositorios
        services.AddScoped<IPatientRepository, PatientRepository>();
        services.AddScoped<IDoctorRepository, DoctorRepository>();
        services.AddScoped<ITreatmentRepository, TreatmentRepository>();
        services.AddScoped<IAppointmentRepository, AppointmentRepository>();
    }
}
```

### 4. Mejores Prácticas para Firebase en Arquitectura DDD

1. **Mapeo limpio entre documentos y entidades**:
   - Usar mappers dedicados para cada tipo de entidad
   - Mantener la lógica de mapeo centralizada
   - Convertir IDs de string a Guid correctamente

2. **Transacciones para operaciones que afectan múltiples documentos**:
   - Usar `RunTransactionAsync` para garantizar consistencia
   - Implementar rollback manual cuando sea necesario

3. **Encapsulamiento de la estructura de datos**:
   - Ocultar completamente los detalles de Firebase
   - No exponer DocumentSnapshot o DocumentReference fuera de la capa de datos

4. **Gestión eficiente de subcollections**:
   - Evaluar si usar subcollections o embeddings según el caso
   - Para relaciones 1:N, considerar embeber los datos en el documento padre

5. **Optimización de consultas**:
   - Crear índices para consultas frecuentes
   - Implementar paginación para grandes conjuntos de datos
   - Utilizar técnicas de fanout para consultas complejas

6. **Manejo de errores**:
   - Capturar y traducir excepciones específicas de Firebase
   - No propagar errores técnicos a capas superiores

### 5. Ejemplo Completo del Flujo de Datos

1. **El usuario interactúa con React**:
   - Componente → Presentador → Servicio API

2. **El controlador API recibe la petición**:
   - Valida datos → Llama servicio de aplicación

3. **El servicio de aplicación coordina**:
   - Obtiene entidades → Ejecuta lógica de negocio → Persiste cambios

4. **El repositorio Firebase**:
   - Convierte entidades a documentos → Actualiza Firestore

5. **La respuesta regresa al usuario**:
   - Repositorio → Servicio → Controlador → Cliente

### 6. Recursos y Referencias

- [Documentación Firebase para .NET](https://firebase.google.com/docs/dotnet/setup)
- [Google.Cloud.Firestore para .NET](https://cloud.google.com/dotnet/docs/reference/Google.Cloud.Firestore/latest)
- Ver ejemplos completos en:
  - `15_Firebase_Repository_Implementation.cs`
  - `16_Data_Core_Firebase_Context.cs`
  - `17_Infrastructure_Firebase_Inyector.cs`




