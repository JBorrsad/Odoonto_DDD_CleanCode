---
description: Template and guidelines for 20_React_Presenter.tsx.
autoAttach: true
filePattern: "regex:.*Presenter\.tsx$"
---
# 20_React_Presenter.tsx Guideline

## Purpose
This rule automatically attaches when you are working on files that match **.*Presenter\.tsx$**.  
It embeds the full reference implementation so you can copy‑paste or use it as a template.

## Template code
```tsx
// EJEMPLO DE PRESENTADOR REACT/TYPESCRIPT (Presentation Layer - Frontend)
// Ruta: src/Presentation/TuProyecto.Web/src/presenters/categories/CategoryPresenter.ts

import { useState, useEffect } from 'react';
import { 
  Category, 
  CategoryReadModel, 
  CategoryCreateModel, 
  CategoryUpdateModel,
  AddFlowToCategoryModel
} from '../../models/categories/Category.model';
import { CategoryService } from '../../services/api/categories/category.service';

/**
 * Características clave de un presentador en el frontend (patrón MVP):
 * 1. Implementa la lógica de presentación y orquesta operaciones
 * 2. Abstrae la vista de los servicios/datos
 * 3. Encapsula la comunicación con servicios API
 * 4. Gestiona el estado y los ciclos de vida de los componentes
 * 5. Implementa la validación y transformación antes y después de la API
 */
export function useCategoryPresenter() {
  // Estado
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Dependencias - servicio API REST
  const categoryService = new CategoryService();

  // Carga inicial
  useEffect(() => {
    loadCategories();
  }, []);

  // Métodos de carga de datos
  const loadCategories = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await categoryService.getAll();
      const mappedCategories = data.map(categoryData => 
        new Category({
          ...categoryData,
          flows: [] // En el listado no vienen los flows completos
        })
      );
      setCategories(mappedCategories);
    } catch (err) {
      setError('Error al cargar las categorías');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const loadCategoryById = async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      const data = await categoryService.getById(id);
      const category = new Category(data);
      setSelectedCategory(category);
      return category;
    } catch (err) {
      setError(`Error al cargar la categoría ${id}`);
      console.error(err);
      return null;
    } finally {
      setLoading(false);
    }
  };

  // Operaciones CRUD
  const createCategory = async (data: CategoryCreateModel) => {
    setLoading(true);
    setError(null);
    try {
      // Validación antes de enviar
      if (!data.name || data.name.trim() === '') {
        throw new Error('El nombre de la categoría es obligatorio');
      }

      const categoryId = await categoryService.create(data);
      
      // Actualizar lista para reflejar el cambio
      await loadCategories();
      
      return categoryId;
    } catch (err) {
      setError('Error al crear la categoría');
      console.error(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const updateCategory = async (id: string, data: CategoryUpdateModel) => {
    setLoading(true);
    setError(null);
    try {
      // Validación antes de enviar
      if (!data.name || data.name.trim() === '') {
        throw new Error('El nombre de la categoría es obligatorio');
      }

      await categoryService.update(id, data);
      
      // Actualizar datos para reflejar el cambio
      if (selectedCategory && selectedCategory.id === id) {
        await loadCategoryById(id);
      }
      await loadCategories();
    } catch (err) {
      setError(`Error al actualizar la categoría ${id}`);
      console.error(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const deleteCategory = async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      await categoryService.delete(id);
      
      // Actualizar datos para reflejar el cambio
      if (selectedCategory && selectedCategory.id === id) {
        setSelectedCategory(null);
      }
      await loadCategories();
    } catch (err) {
      setError(`Error al eliminar la categoría ${id}`);
      console.error(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Operaciones específicas
  const addFlowToCategory = async (categoryId: string, data: AddFlowToCategoryModel) => {
    setLoading(true);
    setError(null);
    try {
      await categoryService.addFlowToCategory(categoryId, data);
      
      // Actualizar datos para reflejar el cambio
      if (selectedCategory && selectedCategory.id === categoryId) {
        await loadCategoryById(categoryId);
      }
      await loadCategories();
    } catch (err) {
      setError(`Error al agregar flujo a la categoría ${categoryId}`);
      console.error(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const removeFlowFromCategory = async (categoryId: string, flowId: string) => {
    setLoading(true);
    setError(null);
    try {
      await categoryService.removeFlowFromCategory(categoryId, flowId);
      
      // Actualizar datos para reflejar el cambio
      if (selectedCategory && selectedCategory.id === categoryId) {
        await loadCategoryById(categoryId);
      }
      await loadCategories();
    } catch (err) {
      setError(`Error al eliminar flujo de la categoría ${categoryId}`);
      console.error(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Devolver los estados y métodos que se exponen a la vista
  return {
    // Estado
    categories,
    selectedCategory,
    loading,
    error,
    
    // Métodos de carga
    loadCategories,
    loadCategoryById,
    
    // Operaciones CRUD
    createCategory,
    updateCategory,
    deleteCategory,
    
    // Operaciones específicas
    addFlowToCategory,
    removeFlowFromCategory
  };
} 
```
