---
description: Template and guidelines for 15_Firebase_Repository_Implementation.cs.
autoAttach: true
filePattern: "regex:src/Data/.*/Repositories/.+Repository\.cs$"
---
# 15_Firebase_Repository_Implementation.cs Guideline

## Purpose
This rule automatically attaches when you are working on files that match **src/Data/.*/Repositories/.+Repository\.cs$**.  
It embeds the full reference implementation so you can copy‑paste or use it as a template.

## Template code
```csharp
// EJEMPLO DE IMPLEMENTACIÓN DE REPOSITORIO PARA FIREBASE (Data Layer)
// Ruta: src/Data/TuProyecto.Data/Repositories/Categories/CategoryRepository.cs

namespace TuProyecto.Data.Repositories.Categories;

using Google.Cloud.Firestore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using TuProyecto.Data.Core.Firebase;
using TuProyecto.Data.Mappings; // Referencia a la capa de mapeos centralizada
using TuProyecto.Domain.Core.Specifications;
using TuProyecto.Domain.Models.Categories;
using TuProyecto.Domain.Models.Flows;
using TuProyecto.Domain.Repositories.Categories;

/// <summary>
/// Características clave de una implementación de repositorio para Firebase en DDD:
/// 1. Implementa la interfaz definida en el dominio
/// 2. Utiliza Firebase SDK para acceso a datos
/// 3. Utiliza mappers centralizados para convertir entre documentos y entidades
/// 4. Aprovecha WithConverter<T> para simplificar las conversiones
/// 5. Soporta consultas basadas en Specification pattern
/// 6. No lanza excepciones de dominio directamente - responsabilidad de Application
/// </summary>
public class CategoryRepository : ICategoryRepository
{
    private readonly FirebaseDbContext _firebaseContext;
    private readonly string _collectionName = "categories";
    private readonly ICategoryMapper _mapper; // Inyectamos un mapper centralizado

    public CategoryRepository(FirebaseDbContext firebaseContext, ICategoryMapper mapper)
    {
        _firebaseContext = firebaseContext;
        _mapper = mapper;

        // Configuramos conversor para la colección categories
        _firebaseContext.ConfigureCollection<Category, CategoryDocument>(
            _collectionName,
            entity => _mapper.ToDocument(entity),
            document => _mapper.ToDomainEntity(document)
        );
    }

    public async Task<Category> GetById(Guid id)
    {
        // Usamos la colección con converter ya configurado
        DocumentSnapshot document = await _firebaseContext.GetCollection<Category>()
            .Document(id.ToString())
            .GetSnapshotAsync();

        if (!document.Exists)
        {
            return null;
        }

        // La conversión la realiza automáticamente el WithConverter configurado
        return document.ConvertTo<Category>();
    }

    public async Task<IEnumerable<Category>> GetAll()
    {
        // Usamos la colección con converter ya configurado
        QuerySnapshot querySnapshot = await _firebaseContext.GetCollection<Category>()
            .GetSnapshotAsync();

        if (querySnapshot.Count == 0)
        {
            return Enumerable.Empty<Category>();
        }

        // La conversión la realiza automáticamente el WithConverter configurado
        return querySnapshot.Documents.Select(doc => doc.ConvertTo<Category>());
    }

    // Implementación para usar Specifications
    public async Task<Category> FindAsync(ISpecification<Category> specification)
    {
        // Este método es un ejemplo y podría requerir adaptaciones según el caso
        // Las especificaciones para Firebase son diferentes a las de EF

        var allItems = await GetAll();
        return allItems.FirstOrDefault(item => specification.IsSatisfiedBy(item));
    }

    // Método para búsqueda paginada
    public async Task<(IEnumerable<Category> Items, string NextPageToken)> GetPaginatedAsync(
        int pageSize = 20,
        string pageToken = null)
    {
        Query query = _firebaseContext.GetCollection<Category>().Limit(pageSize);

        // Si tenemos un token de paginación, lo aplicamos
        if (!string.IsNullOrEmpty(pageToken))
        {
            DocumentSnapshot startAfterDoc = await _firebaseContext.FirestoreDb
                .Collection(_collectionName)
                .Document(pageToken)
                .GetSnapshotAsync();

            if (startAfterDoc.Exists)
            {
                query = query.StartAfter(startAfterDoc);
            }
        }

        // Ejecutar la consulta
        QuerySnapshot querySnapshot = await query.GetSnapshotAsync();

        if (querySnapshot.Count == 0)
        {
            return (Enumerable.Empty<Category>(), null);
        }

        // Convertir documentos a entidades de dominio
        var items = querySnapshot.Documents.Select(doc => doc.ConvertTo<Category>()).ToList();

        // Determinar el token para la siguiente página
        string nextPageToken = querySnapshot.Count < pageSize
            ? null
            : querySnapshot.Documents.Last().Id;

        return (items, nextPageToken);
    }

    public async Task Create(Category entity)
    {
        // Usar directamente el WithConverter configurado
        await _firebaseContext.GetCollection<Category>()
            .Document(entity.Id.ToString())
            .SetAsync(entity);
    }

    public async Task Update(Category entity)
    {
        // Usar directamente el WithConverter configurado
        await _firebaseContext.GetCollection<Category>()
            .Document(entity.Id.ToString())
            .SetAsync(entity, SetOptions.MergeAll);
    }

    public async Task Delete(Category entity)
    {
        await _firebaseContext.GetCollection<Category>()
            .Document(entity.Id.ToString())
            .DeleteAsync();
    }

    public async Task<bool> Exists(Guid id)
    {
        DocumentSnapshot document = await _firebaseContext.GetCollection<Category>()
            .Document(id.ToString())
            .GetSnapshotAsync();

        return document.Exists;
    }

    public async Task AddFlowToCategory(Guid categoryId, Guid flowId)
    {
        // Implementar usando una transacción Firestore para garantizar consistencia
        await _firebaseContext.FirestoreDb.RunTransactionAsync(async transaction =>
        {
            // Obtener la categoría
            var categoryRef = _firebaseContext.GetCollection<Category>()
                .Document(categoryId.ToString());

            DocumentSnapshot categorySnapshot = await transaction.GetSnapshotAsync(categoryRef);

            if (!categorySnapshot.Exists)
            {
                return; // No lanzamos excepciones, el servicio de aplicación manejará esto
            }

            // Obtener el flow
            var flowRef = _firebaseContext.GetCollection<Flow>()
                .Document(flowId.ToString());

            DocumentSnapshot flowSnapshot = await transaction.GetSnapshotAsync(flowRef);

            if (!flowSnapshot.Exists)
            {
                return; // No lanzamos excepciones, el servicio de aplicación manejará esto
            }

            // Actualizar el flow para establecer su categoría
            transaction.Update(flowRef, new Dictionary<string, object>
            {
                { "categoryId", categoryId.ToString() }
            });
        });
    }

    public async Task RemoveFlowFromCategory(Guid categoryId, Guid flowId)
    {
        // Implementar usando una transacción Firestore para garantizar consistencia
        await _firebaseContext.FirestoreDb.RunTransactionAsync(async transaction =>
        {
            // Obtener la categoría
            var categoryRef = _firebaseContext.GetCollection<Category>()
                .Document(categoryId.ToString());

            DocumentSnapshot categorySnapshot = await transaction.GetSnapshotAsync(categoryRef);

            if (!categorySnapshot.Exists)
            {
                return; // No lanzamos excepciones, el servicio de aplicación manejará esto
            }

            // Obtener el flow
            var flowRef = _firebaseContext.GetCollection<Flow>()
                .Document(flowId.ToString());

            DocumentSnapshot flowSnapshot = await transaction.GetSnapshotAsync(flowRef);

            if (!flowSnapshot.Exists)
            {
                return; // No lanzamos excepciones, el servicio de aplicación manejará esto
            }

            // Verificar que el flujo pertenece a esta categoría
            var flowData = flowSnapshot.ConvertTo<FlowDocument>();
            if (flowData.CategoryId != categoryId.ToString())
            {
                return; // No lanzamos excepciones, el servicio de aplicación manejará esto
            }

            // Actualizar el flow para remover su categoría
            transaction.Update(flowRef, new Dictionary<string, object>
            {
                { "categoryId", null }
            });
        });
    }
}

// Las clases de documentos se mueven al mapper centralizado
// y los métodos de mapeo también

// Ejemplo de extensiones para el FirebaseDbContext
namespace TuProyecto.Data.Core.Firebase
{
    public static class FirebaseDbContextExtensions
    {
        public static void ConfigureCollection<TEntity, TDocument>(
            this FirebaseDbContext context,
            string collectionName,
            Func<TEntity, TDocument> toDocument,
            Func<TDocument, TEntity> toDomainEntity)
        {
            // Almacenar en el contexto la configuración para esta colección
            context.RegisterConverter(collectionName, toDocument, toDomainEntity);
        }

        public static CollectionReference GetCollection<TEntity>(this FirebaseDbContext context)
        {
            // Obtener la colección configurada con WithConverter
            return context.GetCollectionWithConverter<TEntity>();
        }
    }
}

// Ejemplo de interfaz para el mapper centralizado
namespace TuProyecto.Data.Mappings
{
    public interface ICategoryMapper
    {
        Category ToDomainEntity(CategoryDocument document);
        CategoryDocument ToDocument(Category entity);
    }

    // Esta clase se debe implementar en la capa de Mappings
    public class CategoryDocument
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public DateTime CreationDate { get; set; }
        public DateTime EditDate { get; set; }
    }

    // La implementación real estaría en otra parte, pero para propósitos de ejemplo:
    public class CategoryMapper : ICategoryMapper
    {
        public Category ToDomainEntity(CategoryDocument document)
        {
            Category category = Category.Create(Guid.Parse(document.Id));
            // Establecer propiedades usando métodos del dominio
            category.SetName(document.Name);

            // Las propiedades de auditoría se manejan así para evitar setters públicos
            typeof(Category).GetProperty("CreationDate")?.SetValue(category, document.CreationDate);
            typeof(Category).GetProperty("EditDate")?.SetValue(category, document.EditDate);

            return category;
        }

        public CategoryDocument ToDocument(Category entity)
        {
            return new CategoryDocument
            {
                Id = entity.Id.ToString(),
                Name = entity.Name,
                CreationDate = entity.CreationDate,
                EditDate = entity.EditDate
            };
        }
    }
}
```
