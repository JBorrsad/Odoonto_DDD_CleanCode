---
description:
globs:
alwaysApply: false
---
---

# Money Value Object Guidelines

## Description
A value object that represents a monetary amount with a decimal value and currency.

## When to apply
When implementing the `Money` value object or any code that deals with monetary values.

## Responsibilities
- Represent a monetary amount with a specific currency
- Enforce business rules (non-negative amount)
- Provide operations for monetary calculations
- Implement value equality (compare by value, not reference)
- Protect against floating-point precision issues

## Code Example
```csharp
// VALUE OBJECT EXAMPLE: Money
// Ruta: src/Domain/Odoonto.Domain/Models/ValueObjects/Money.cs

namespace Odoonto.Domain.Models.ValueObjects;

using System;
using Odoonto.Domain.Core.Models.Exceptions;

/// <summary>
/// Value Object que representa un valor monetario con monto y divisa
/// Características clave:
/// 1. Inmutabilidad - sin setters
/// 2. Validación en el constructor
/// 3. Operaciones aritméticas que devuelven nuevas instancias
/// 4. Implementa Equals/GetHashCode basados en el valor
/// 5. Comparación precisa de valores decimales
/// </summary>
public sealed class Money : IEquatable<Money>
{
    // Propiedades inmutables (solo getters)
    public decimal Amount { get; }
    public string Currency { get; }

    // Constantes para monedas soportadas
    public const string EUR = "EUR";
    public const string USD = "USD";

    // Constructor privado - solo accesible a través del método factory
    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    // Método Factory para crear instancias válidas
    public static Money Create(decimal amount, string currency)
    {
        // Validar que el monto no sea negativo
        if (amount < 0)
        {
            throw new InvalidValueException("Money amount cannot be negative.");
        }

        // Validar la divisa
        if (string.IsNullOrWhiteSpace(currency))
        {
            throw new InvalidValueException("Currency cannot be empty.");
        }

        // Normalizar la divisa a mayúsculas
        string normalizedCurrency = currency.Trim().ToUpperInvariant();

        // Opcionalmente, validar que sea una divisa soportada
        if (!IsValidCurrency(normalizedCurrency))
        {
            throw new InvalidValueException($"Currency '{normalizedCurrency}' is not supported.");
        }

        // Crear una nueva instancia
        return new Money(Math.Round(amount, 2), normalizedCurrency);
    }

    // Validar si es una divisa soportada
    private static bool IsValidCurrency(string currency)
    {
        // Solo permitir EUR y USD por ejemplo
        return currency == EUR || currency == USD;
    }

    // Método de fábrica conveniente para crear EUR
    public static Money Euro(decimal amount)
    {
        return Create(amount, EUR);
    }

    // Método de fábrica conveniente para crear USD
    public static Money Dollar(decimal amount)
    {
        return Create(amount, USD);
    }

    // Operaciones aritméticas - siempre devuelven nuevas instancias
    public Money Add(Money other)
    {
        EnsureSameCurrency(other);
        return new Money(Amount + other.Amount, Currency);
    }

    public Money Subtract(Money other)
    {
        EnsureSameCurrency(other);
        decimal result = Amount - other.Amount;
        
        // Asegurar que el resultado no sea negativo
        if (result < 0)
        {
            throw new InvalidOperationException("Money amount cannot be negative after subtraction.");
        }
        
        return new Money(result, Currency);
    }

    public Money Multiply(decimal factor)
    {
        if (factor < 0)
        {
            throw new InvalidOperationException("Cannot multiply money by a negative factor.");
        }
        
        return new Money(Amount * factor, Currency);
    }

    // Asegurar que las monedas sean de la misma divisa para operaciones
    private void EnsureSameCurrency(Money other)
    {
        if (Currency != other.Currency)
        {
            throw new InvalidOperationException($"Cannot perform operations on money with different currencies: {Currency} and {other.Currency}");
        }
    }

    // Representación como string
    public override string ToString()
    {
        return $"{Amount:F2} {Currency}";
    }

    // Implementación de IEquatable<T>
    public bool Equals(Money other)
    {
        if (other is null)
            return false;

        // Comparar divisa (case-sensitive)
        if (Currency != other.Currency)
            return false;

        // Comparar monto (hasta 2 decimales para evitar problemas de precisión)
        return Math.Round(Amount, 2) == Math.Round(other.Amount, 2);
    }

    // Sobreescritura de Object.Equals
    public override bool Equals(object obj)
    {
        return obj is Money other && Equals(other);
    }

    // Sobreescritura de Object.GetHashCode
    public override int GetHashCode()
    {
        return HashCode.Combine(Math.Round(Amount, 2), Currency);
    }

    // Operadores de igualdad
    public static bool operator ==(Money left, Money right)
    {
        if (left is null)
            return right is null;

        return left.Equals(right);
    }

    public static bool operator !=(Money left, Money right)
    {
        return !(left == right);
    }

    // Operadores de comparación
    public static bool operator >(Money left, Money right)
    {
        left.EnsureSameCurrency(right);
        return left.Amount > right.Amount;
    }

    public static bool operator <(Money left, Money right)
    {
        left.EnsureSameCurrency(right);
        return left.Amount < right.Amount;
    }

    // Operadores aritméticos
    public static Money operator +(Money left, Money right)
    {
        return left.Add(right);
    }

    public static Money operator -(Money left, Money right)
    {
        return left.Subtract(right);
    }

    public static Money operator *(Money money, decimal factor)
    {
        return money.Multiply(factor);
    }
}
