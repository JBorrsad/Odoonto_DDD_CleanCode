---
description: 
globs: 
alwaysApply: true
---
# Arquitectura con API REST y Firebase en el Backend

Este documento describe la arquitectura donde el frontend React se comunica exclusivamente con un backend .NET mediante una API REST, y es este backend quien interactúa con Firebase como sistema de persistencia de datos, reemplazando a una base de datos relacional tradicional.

## 1. Visión General de la Arquitectura

La arquitectura sigue un diseño Domain-Driven Design (DDD) puro:

```
┌─────────────────────┐       ┌───────────────────────────────────────────────────┐       ┌───────────────┐
│                     │       │                   BACKEND (.NET)                   │       │               │
│                     │       │                                                   │       │               │
│                     │       │ ┌───────────┐  ┌───────────┐  ┌───────────┐       │       │               │
│    FRONTEND         │       │ │           │  │           │  │           │       │       │               │
│    (React/          │  API  │ │ Presenta- │  │ Applica-  │  │  Domain   │       │       │               │
│    TypeScript)      ├───────┼─► tion      ├──► tion      ├──►           │       │       │               │
│                     │  REST │ │ Layer     │  │ Layer     │  │  Layer    │       │       │    Firebase   │
│                     │       │ │ (API)     │  │           │  │           │       │       │    Firestore  │
│                     │       │ │           │  │           │  │           │       │       │  (Persistencia│
│                     │       │ └─────┬─────┘  └─────┬─────┘  └─────┬─────┘       │       │    de datos)  │
│                     │       │       │              │              │             │       │               │
│                     │       │       │              │              │             │       │               │
│                     │       │       └──────────────┼──────────────┘             │       │               │
│                     │       │                      │                            │       │               │
│                     │       │              ┌───────▼─────┐                      │       │               │
│                     │       │              │             │                      │       │               │
│                     │       │              │ Data Layer  ├──────────────────────┼───────►               │
│                     │       │              │ (Firebase)  │                      │       │               │
│                     │       │              │             │                      │       │               │
│                     │       │              └─────────────┘                      │       │               │
│                     │       │                                                   │       │               │
└─────────────────────┘       └───────────────────────────────────────────────────┘       └───────────────┘
```

**IMPORTANTE:**

- El frontend NUNCA se comunica directamente con Firebase
- La API REST sigue siendo necesaria como punto de entrada para todas las operaciones
- Firebase solo reemplaza la capa de persistencia, no cambia la arquitectura general

## 2. Componentes de la Arquitectura

### 2.1. Frontend (React/TypeScript)

El frontend es una aplicación React/TypeScript completamente separada que:

- Se comunica EXCLUSIVAMENTE con el backend a través de la API REST
- Nunca accede directamente a Firebase
- Sigue patrón MVP (Model-View-Presenter) internamente
- Se sitúa ÚNICAMENTE en la capa de Presentación según DDD

```typescript
// Ejemplo de servicio en el frontend para comunicarse con la API
// src/services/api/category.service.ts
import axios from "axios";
import { CategoryDto } from "../models/category.model";

export class CategoryApiService {
  private readonly baseUrl = "https://api.odoonto.com/api/categories";

  async getAll(): Promise<CategoryDto[]> {
    const response = await axios.get(this.baseUrl);
    return response.data;
  }

  async getById(id: string): Promise<CategoryDto> {
    const response = await axios.get(`${this.baseUrl}/${id}`);
    return response.data;
  }

  // Más métodos para comunicarse con la API...
}
```

### 2.2. Backend API (ASP.NET Core)

La API REST es la capa de Presentación del backend:

- Expone endpoints documentados con Swagger
- Se implementa con controladores ASP.NET Core
- Utiliza servicios de la capa de Aplicación
- No contiene lógica de negocio

```csharp
// Ejemplo de controlador API
[ApiController]
[Route("api/[controller]")]
public class CategoriesController : ControllerBase
{
    private readonly ICategoryAppService _categoryService;

    public CategoriesController(ICategoryAppService categoryService)
    {
        _categoryService = categoryService;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<CategoryDto>>> GetAll()
    {
        return Ok(await _categoryService.GetAll());
    }

    // Más endpoints...
}
```

### 2.3. Capa de Datos con Firebase

La capa de Datos es donde se implementa la interacción con Firebase:

- Implementa las interfaces de repositorio definidas en el dominio
- Utiliza el SDK de Firebase para C#
- Abstrae completamente los detalles de Firebase del resto de la aplicación

```csharp
// Implementación de repositorio para Firebase
public class CategoryRepository : ICategoryRepository
{
    private readonly FirebaseDbContext _firebaseContext;
    private readonly string _collectionName = "categories";

    public CategoryRepository(FirebaseDbContext firebaseContext)
    {
        _firebaseContext = firebaseContext;
    }

    public async Task<IEnumerable<Category>> GetAll()
    {
        // Implementación usando Firebase SDK
        var snapshot = await _firebaseContext.FirestoreDb
            .Collection(_collectionName)
            .GetSnapshotAsync();

        return snapshot.Documents
            .Select(doc => ConvertToEntity(doc))
            .ToList();
    }

    // Más métodos...
}
```

## 3. Flujo de Datos en la Aplicación

1. **Usuario interactúa con el frontend**:

   - El usuario realiza una acción en la interfaz
   - El componente React llama a un presentador
   - El presentador llama al servicio API

2. **Frontend se comunica con el backend**:

   - El servicio API realiza una petición HTTP al endpoint correspondiente
   - La petición incluye datos en formato JSON (si es necesario)
   - La petición puede incluir tokens de autenticación

3. **El controlador API procesa la petición**:

   - Valida los datos de entrada
   - Llama al servicio de aplicación correspondiente
   - Retorna una respuesta HTTP

4. **El servicio de aplicación ejecuta la lógica de negocio**:

   - Orquesta las operaciones necesarias
   - Utiliza entidades del dominio
   - Llama a repositorios para persistencia

5. **El repositorio interactúa con Firebase**:

   - Traduce operaciones del dominio a operaciones Firestore
   - Ejecuta consultas, transacciones o actualizaciones
   - Convierte documentos Firestore a entidades de dominio

6. **El resultado vuelve al usuario**:
   - Respuesta HTTP → Servicio frontend → Presentador → Vista

## 4. Estructura del Frontend con React y TypeScript

### 4.1. Estructura de Directorios

```
frontend/
  ├── public/                 # Archivos estáticos públicos
  ├── src/                    # Código fuente
  │   ├── models/             # Modelos de dominio (capa de dominio)
  │   │   ├── common/         # Interfaces y tipos comunes
  │   │   ├── categories/     # Modelos de categorías
  │   │   ├── flows/          # Modelos de flujos
  │   │   └── nodes/          # Modelos de nodos
  │   │
  │   ├── services/           # Servicios de datos (capa de infraestructura)
  │   │   ├── api/            # Servicios de API REST
  │   │   │   ├── base/       # Funcionalidad base para servicios de API
  │   │   │   ├── categories/ # Servicios específicos para categorías
  │   │   │   └── ...         # Otros servicios de API
  │   │   │
  │   │   └── utils/          # Utilidades y funciones auxiliares
  │   │
  │   ├── presenters/         # Presentadores (capa de aplicación)
  │   │   ├── categories/     # Presentadores para categorías
  │   │   ├── flows/          # Presentadores para flujos
  │   │   ├── nodes/          # Presentadores para nodos
  │   │   └── hooks/          # Hooks personalizados para lógica reutilizable
  │   │
  │   ├── views/              # Vistas (componentes de UI)
  │   │   ├── components/     # Componentes reutilizables
  │   │   │   ├── atoms/      # Componentes atómicos (botones, inputs, etc.)
  │   │   │   ├── molecules/  # Componentes moleculares (tarjetas, formularios, etc.)
  │   │   │   └── organisms/  # Componentes organizacionales (tablas, paneles, etc.)
  │   │   │
  │   │   ├── pages/          # Páginas/rutas de la aplicación
  │   │   │   ├── categories/ # Páginas relacionadas con categorías
  │   │   │   ├── flows/      # Páginas relacionadas con flujos
  │   │   │   └── ...         # Otras páginas
  │   │   │
  │   │   └── layouts/        # Layouts y estructura de la aplicación
  │   │
  │   ├── context/            # Contextos de React (estado global)
  │   │   ├── auth/           # Contexto de autenticación
  │   │   └── ...             # Otros contextos
  │   │
  │   ├── config/             # Configuración de la aplicación
  │   │   ├── routes.tsx      # Configuración de rutas
  │   │   └── theme.ts        # Configuración del tema
  │   │
  │   ├── styles/             # Estilos globales y temas
  │   │   ├── global.css      # Estilos globales
  │   │   └── variables.css   # Variables CSS
  │   │
  │   ├── locales/            # Archivos de internacionalización
  │   │   ├── es/             # Traducciones en español
  │   │   └── en/             # Traducciones en inglés
  │   │
  │   ├── App.tsx             # Componente principal
  │   └── index.tsx           # Punto de entrada
  │
  ├── tests/                  # Pruebas
  │   ├── unit/               # Pruebas unitarias
  │   ├── integration/        # Pruebas de integración
  │   └── e2e/                # Pruebas end-to-end
  │
  ├── .env                    # Variables de entorno
  ├── .env.development        # Variables específicas para desarrollo
  ├── .env.production         # Variables específicas para producción
  ├── package.json            # Dependencias y scripts
  ├── tsconfig.json           # Configuración de TypeScript
  └── README.md               # Documentación
```

### 4.2. Enfoque de DDD en el Frontend

Aunque DDD se concibió originalmente para el backend, sus principios pueden adaptarse al frontend:

- **Capa de Dominio (Modelos)**: Define entidades y objetos de valor del frontend.
- **Capa de Infraestructura (Servicios)**: Implementa comunicación con la API REST.
- **Capa de Aplicación (Presentadores)**: Orquesta lógica de presentación y casos de uso.
- **Capa de UI (Vistas)**: Componentes React responsables de la presentación.

### 4.3. Patrón MVP en React

El patrón MVP (Model-View-Presenter) se implementa de la siguiente manera:

1. **Model**: Representado por los modelos en `src/models/`.
2. **View**: Componentes React en `src/views/`.
3. **Presenter**: Custom hooks en `src/presenters/`.

## 5. Consideraciones Importantes

### 5.1. Seguridad

- **API Gateway**: Implementar autenticación y autorización en la API.
- **JWT**: Utilizar tokens JWT para autenticar peticiones del frontend.
- **Backend seguro**: El backend maneja las credenciales de Firebase de forma segura.
- **Validación**: Validar datos tanto en el frontend como en el backend.

### 5.2. Rendimiento

- **Índices de Firestore**: Crear índices para consultas frecuentes.
- **Paginación**: Implementar paginación para grandes conjuntos de datos.
- **Caching**: Utilizar estrategias de caché en el frontend y backend.

### 5.3. Sincronización de Datos

- **Polling o SignalR**: Para actualizaciones en tiempo real desde el backend.
- **Optimistic UI**: Implementar actualizaciones optimistas en la interfaz.
- **Manejo de conflictos**: Estrategia cuando múltiples usuarios editan el mismo recurso.

## 6. Firebase Best Practices

1. **Abstraer el acceso a Firebase**: Siempre detrás de interfaces de repositorio.
2. **No exponer detalles de Firebase**: Mantenerlos encapsulados en la capa de datos.
3. **Manejo centralizado**: Utilizar una clase FirebaseContext para gestionar la conexión.
4. **Usar transacciones**: Para operaciones que afectan a múltiples documentos.
5. **Mapeos claros**: Establecer conversiones bidireccionales entre documentos y entidades.
6. **Caching estratégico**: Reducir lecturas implementando caché para datos frecuentes.
7. **Estructura de colecciones**: Diseñar cuidadosamente basándose en patrones de acceso.

